name: Deploy Backend to EC2

on:
  push:
    branches: [ "main" ]
    paths:
      - "backend/**"
      - ".github/workflows/deploy_backend.yml"
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: eu-central-1
      INSTANCE_NAME: nat20-backend
      SERVICE_NAME: scheduler
      ARTIFACT_PREFIX: backend/

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEPLOY_ROLE_ARN }}
          role-session-name: deploy-backend
          aws-region: ${{ env.AWS_REGION }}

      - name: Derive artifact bucket name
        id: acct
        run: |
          set -euo pipefail
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          ARTIFACT_BUCKET="nat20scheduling-com-deploy-artifacts-$ACCOUNT_ID"
          echo "ARTIFACT_BUCKET=$ARTIFACT_BUCKET" >> $GITHUB_ENV

      - name: Verify artifact bucket exists (managed by Terraform)
        run: |
          set -euo pipefail
          if ! aws s3api head-bucket --bucket "$ARTIFACT_BUCKET" 2>/dev/null; then
            echo "Artifact bucket $ARTIFACT_BUCKET not found" >&2
            exit 1
          fi

      - name: Locate newest backend artifact
        id: artifact
        run: |
          set -euo pipefail
          latest_key=$(aws s3api list-objects-v2 --bucket "$ARTIFACT_BUCKET" --prefix "${ARTIFACT_PREFIX}" \
            --query 'reverse(sort_by(Contents,&LastModified))[0].Key' --output text)
          if [ "$latest_key" = "None" ] || [ -z "$latest_key" ]; then
            echo "No artifacts found under s3://$ARTIFACT_BUCKET/${ARTIFACT_PREFIX}" >&2
            exit 1
          fi
          echo "ARTIFACT_KEY=$latest_key" >> $GITHUB_ENV
          echo "Using artifact: $latest_key"

      - name: Download artifact locally (optional)
        run: |
          set -euo pipefail
          aws s3 cp "s3://$ARTIFACT_BUCKET/$ARTIFACT_KEY" backend.zip
          unzip -l backend.zip | sed -n '1,100p' || true

      - name: Resolve backend instance-id by Name tag
        id: instance
        run: |
          set -euo pipefail
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${{ env.INSTANCE_NAME }}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' --output text)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "No running instance found with Name=${{ env.INSTANCE_NAME }}" >&2
            exit 1
          fi
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "Deploying to $INSTANCE_ID"

      - name: Build SSM command parameters
        run: |
          set -euo pipefail
          cat > /tmp/ssm_commands.txt <<'CMDS'
          set -euo pipefail
          sudo mkdir -p /opt/app /tmp/installation
          sudo chown -R root:root /tmp/installation

          # 1) Download and extract artifact
          aws s3 cp s3://${ARTIFACT_BUCKET}/${ARTIFACT_KEY} /tmp/installation/backend.zip
          rm -rf /tmp/installation/unpack
          mkdir -p /tmp/installation/unpack
          unzip -o /tmp/installation/backend.zip -d /tmp/installation/unpack/

          # 2) Prepare /opt/app and copy files
          sudo mkdir -p /opt/app
          if systemctl is-active --quiet ${SERVICE_NAME}; then sudo systemctl stop ${SERVICE_NAME}; fi

          SRC="/tmp/installation/unpack"
          if [ -d "/tmp/installation/unpack/app" ]; then SRC="/tmp/installation/unpack/app"; fi

          sudo rsync -a --delete "$SRC"/ /opt/app/

          # 3) Install service unit file if present
          if [ -f "/tmp/installation/unpack/${SERVICE_NAME}.service" ]; then
            sudo cp -f "/tmp/installation/unpack/${SERVICE_NAME}.service" /etc/systemd/system/${SERVICE_NAME}.service
          fi
          if [ -f "/opt/app/${SERVICE_NAME}.service" ]; then
            sudo cp -f "/opt/app/${SERVICE_NAME}.service" /etc/systemd/system/${SERVICE_NAME}.service
          fi

          # 4) Fetch secrets from SSM
          JWT_SECRET=$(aws ssm get-parameter --name /nat20/backend/JWT_SECRET --with-decryption --query Parameter.Value --output text)
          MONGO_USER=$(aws ssm get-parameter --name /nat20/mongo/USER --with-decryption --query Parameter.Value --output text)
          MONGO_PASS=$(aws ssm get-parameter --name /nat20/mongo/PASSWORD --with-decryption --query Parameter.Value --output text)
          MONGO_HOST=$(aws ssm get-parameter --name /nat20/mongo/HOST --with-decryption --query Parameter.Value --output text)
          MONGO_DB=$(aws ssm get-parameter --name /nat20/mongo/DB --with-decryption --query Parameter.Value --output text)

          # 5) Create .env file
          cat > /opt/app/.env <<EOF
          JWT_SECRET=$JWT_SECRET
          MONGO_USER=$MONGO_USER
          MONGO_PASS=$MONGO_PASS
          MONGO_HOST=$MONGO_HOST
          MONGO_DB=$MONGO_DB
          PORT=3000
          NODE_ENV=production
          EOF
          sudo chown root:root /opt/app/.env
          sudo chmod 600 /opt/app/.env

          # 6) Install deps
          cd /opt/app
          if [ -f package-lock.json ]; then
            npm ci --omit=dev
          else
            npm install --omit=dev
          fi

          # 7) Reload and restart service
          sudo systemctl daemon-reload
          sudo systemctl enable ${SERVICE_NAME} || true
          sudo systemctl restart ${SERVICE_NAME} || (journalctl -u ${SERVICE_NAME} --no-pager -n 200; exit 1)

          # 8) Verify
          sleep 2
          ss -lntp | sed -n "1,200p" || true
          curl -sS -o /dev/null -w 'HTTP:%{http_code}\n' http://127.0.0.1:3000/ || true
          rm -rf /tmp/installation
          CMDS

          jq -Rs '{commands: (split("\n") | map(select(length>0)))}' /tmp/ssm_commands.txt > /tmp/ssm_params.json

      - name: Kick off SSM command and wait
        id: ssm
        run: |
          set -euo pipefail
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "$INSTANCE_ID" \
            --region "$AWS_REGION" \
            --comment "Deploy backend app from private S3 artifact; secrets from SSM" \
            --parameters file:///tmp/ssm_params.json \
            --query "Command.CommandId" --output text)

          echo "Waiting for SSM command ${CMD_ID} to finish..."
          for i in $(seq 1 60); do
            STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text)
            echo "SSM status: $STATUS"
            case "$STATUS" in
              Success) break ;;
              Failed|Cancelled|TimedOut)
                echo "SSM STDOUT"
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text || true
                echo
                echo "SSM STDERR"
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text || true
                echo
                echo "Remote deploy script failed with status: $STATUS" >&2
                exit 1
              ;;
            esac
            sleep 5
          done

          echo "SSM STDOUT"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text || true
          echo
          echo "SSM STDERR"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text || true
          echo

      - name: Clean up local artifact
        if: always()
        run: rm -f backend.zip
