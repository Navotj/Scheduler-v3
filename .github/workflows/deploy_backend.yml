name: Deploy Backend to EC2

on:
  push:
    branches: [ "main" ]
    paths:
      - "backend/**"
      - ".github/workflows/deploy_backend.yml"
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-central-1

    - name: Derive artifact bucket name
      id: acct
      run: |
        set -euo pipefail
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        ARTIFACT_BUCKET="nat20scheduling-com-deploy-artifacts-$ACCOUNT_ID"
        echo "ARTIFACT_BUCKET=$ARTIFACT_BUCKET" >> $GITHUB_ENV

    - name: Verify artifact bucket exists (managed by Terraform)
      run: |
        set -euo pipefail
        if ! aws s3api head-bucket --bucket "$ARTIFACT_BUCKET" 2>/dev/null; then
          echo "Artifact bucket $ARTIFACT_BUCKET does not exist. Run the Terraform workflow first." >&2
          exit 1
        fi

    - name: Get Backend Instance ID from tag
      id: backend_instance
      run: |
        set -euo pipefail
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=terraform-backend" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

    - name: Zip backend files (code only, no secrets)
      run: |
        set -euo pipefail
        cd backend
        zip -r ../backend.zip .
        cd ..

    - name: Upload artifact to private S3 (encrypted)
      run: |
        set -euo pipefail
        KEY="backend/${GITHUB_SHA}.zip"
        echo "ARTIFACT_KEY=$KEY" >> $GITHUB_ENV
        aws s3 cp backend.zip "s3://$ARTIFACT_BUCKET/$KEY" --sse AES256

    - name: Deploy on instance via SSM (download from S3, render .env from SSM)
      env:
        INSTANCE_ID: ${{ env.INSTANCE_ID }}
        ARTIFACT_BUCKET: ${{ env.ARTIFACT_BUCKET }}
        ARTIFACT_KEY: ${{ env.ARTIFACT_KEY }}
      run: |
        set -euo pipefail

        # Send the command; use single-quoted JSON so $... is NOT expanded on the runner
        CMD_ID=$(aws ssm send-command \
          --document-name "AWS-RunShellScript" \
          --instance-ids "$INSTANCE_ID" \
          --region eu-central-1 \
          --comment "Deploy backend app from private S3 artifact; secrets from SSM" \
          --parameters '{
            "commands": [
              "set -e",
              "sudo mkdir -p /opt/app /tmp/installation",
              "sudo chown -R root:root /tmp/installation",
              "aws s3 cp s3://'${ARTIFACT_BUCKET}'/'${ARTIFACT_KEY}' /tmp/installation/backend.zip",
              "unzip -o /tmp/installation/backend.zip -d /tmp/installation/",
              "sudo bash -lc '\''rm -rf /opt/app/* /opt/app/.* 2>/dev/null || true'\''",
              "sudo mv /tmp/installation/app/* /opt/app || sudo mv /tmp/installation/* /opt/app || true",
              "JWT_SECRET=$(aws ssm get-parameter --name /nat20/backend/JWT_SECRET --with-decryption --query Parameter.Value --output text)",
              "MONGO_USER=$(aws ssm get-parameter --name /nat20/mongo/USER --with-decryption --query Parameter.Value --output text)",
              "MONGO_PASS=$(aws ssm get-parameter --name /nat20/mongo/PASSWORD --with-decryption --query Parameter.Value --output text)",
              "MONGO_HOST=$(aws ssm get-parameter --name /nat20/mongo/HOST --with-decryption --query Parameter.Value --output text || echo mongo.nat20scheduling.com)",
              "MONGO_DB=$(aws ssm get-parameter --name /nat20/mongo/DB --with-decryption --query Parameter.Value --output text || echo nat20)",
              "echo \"JWT_SECRET=$JWT_SECRET\" | sudo tee /opt/app/.env >/dev/null",
              "echo \"MONGO_URI=mongodb://$MONGO_USER:$MONGO_PASS@$MONGO_HOST:27017/$MONGO_DB?authSource=admin\" | sudo tee -a /opt/app/.env >/dev/null",
              "cd /opt/app && npm ci --omit=dev || npm install",
              "if [ -f /opt/app/scheduler.service ]; then sudo mv /opt/app/scheduler.service /etc/systemd/system/scheduler.service; fi",
              "sudo systemctl daemon-reload",
              "sudo systemctl enable scheduler || true",
              "sudo systemctl restart scheduler",
              "rm -f /tmp/installation/backend.zip",
              "aws s3 rm s3://'${ARTIFACT_BUCKET}'/'${ARTIFACT_KEY}' || true"
            ]
          }' \
          --query 'Command.CommandId' --output text)

        # Poll for completion and print output
        for i in $(seq 1 30); do
          STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text || true)
          if [ "$STATUS" = "InProgress" ] || [ "$STATUS" = "Pending" ]; then
            sleep 5
            continue
          fi
          echo "SSM status: $STATUS"
          echo "SSM STDOUT"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text || true
          echo "SSM STDERR"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text || true
          [ "$STATUS" = "Success" ] && exit 0 || { echo "Remote deploy script failed with status: $STATUS" >&2; exit 1; }
        done

        echo "Timed out waiting for SSM command to finish" >&2
        exit 1

    - name: Clean up local artifact
      if: always()
      run: rm -f backend.zip
