name: Deploy Backend

on:
  workflow_dispatch: {}
  push:
    branches: [ "main" ]
    paths:
      - 'backend/**'
      - '.github/workflows/deploy_backend.yml'

concurrency:
  group: deploy-backend-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  APP_PREFIX: ${{ vars.APP_PREFIX }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  # Target all SSM-managed instances with this EC2 tag (stable across recreations)
  BACKEND_SSM_TARGET_KEY:   tag:Name
  BACKEND_SSM_TARGET_VALUE: ${{ vars.APP_PREFIX }}-backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    steps:
      - name: checkout
        uses: actions/checkout@v5

      - name: configure aws credentials (keys only)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: ensure aws cli
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v aws >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y unzip >/dev/null
            curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o awscliv2.zip
            unzip -q awscliv2.zip
            sudo ./aws/install
          fi
          aws --version

      - name: sanity checks
        shell: bash
        run: |
          set -euo pipefail
          [[ -n "${APP_PREFIX}" ]] || { echo "APP_PREFIX is empty"; exit 1; }
          [[ -n "${AWS_REGION}"  ]] || { echo "AWS_REGION is empty";  exit 1; }
          [[ -d "backend/app" ]] || { echo "missing: backend/app"; exit 1; }
          [[ -f "backend/scheduler.service" ]] || { echo "missing: backend/scheduler.service"; exit 1; }

          # Define artifact bucket (separate from frontend bucket)
          ARTIFACT_BUCKET="${APP_PREFIX}-artifacts"
          echo "ARTIFACT_BUCKET=${ARTIFACT_BUCKET}" >> "$GITHUB_ENV"

          # Optional: warn if no instances currently match the SSM target (doesn't hard-fail)
          MATCHING_INSTANCES=$(aws ssm describe-instance-information \
            --filters "Key=tag:Name,Values=${BACKEND_SSM_TARGET_VALUE}" \
            --query "InstanceInformationList[].InstanceId" --output text || true)
          if [[ -z "${MATCHING_INSTANCES}" || "${MATCHING_INSTANCES}" == "None" ]]; then
            echo "WARN: No SSM-managed instances currently match ${BACKEND_SSM_TARGET_KEY}=${BACKEND_SSM_TARGET_VALUE}" >&2
          else
            echo "Found SSM instances: ${MATCHING_INSTANCES}"
          fi

      - name: ensure artifact bucket exists (create if missing)
        shell: bash
        run: |
          set -euo pipefail
          : "${ARTIFACT_BUCKET:?missing}"
          : "${AWS_REGION:?missing}"

          if aws s3api head-bucket --bucket "${ARTIFACT_BUCKET}" 2>/dev/null; then
            echo "Bucket ${ARTIFACT_BUCKET} exists"
          else
            echo "Creating bucket ${ARTIFACT_BUCKET} in ${AWS_REGION}"
            if [[ "${AWS_REGION}" == "us-east-1" ]]; then
              aws s3api create-bucket --bucket "${ARTIFACT_BUCKET}"
            else
              aws s3api create-bucket --bucket "${ARTIFACT_BUCKET}" \
                --create-bucket-configuration LocationConstraint="${AWS_REGION}"
            fi
          fi

          # Harden minimal settings so uploads work and are encrypted
          aws s3api put-bucket-encryption --bucket "${ARTIFACT_BUCKET}" --server-side-encryption-configuration '{
            "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]
          }'

          # Block public access
          aws s3api put-public-access-block --bucket "${ARTIFACT_BUCKET}" --public-access-block-configuration '{
            "BlockPublicAcls": true,
            "IgnorePublicAcls": true,
            "BlockPublicPolicy": true,
            "RestrictPublicBuckets": true
          }'

          # Prefer bucket-owner enforced ownership to avoid ACL issues (no-op if not supported)
          aws s3api put-bucket-ownership-controls --bucket "${ARTIFACT_BUCKET}" --ownership-controls '{
            "Rules":[{"ObjectOwnership":"BucketOwnerEnforced"}]
          }' || true

          # Enable versioning (optional but helpful)
          aws s3api put-bucket-versioning --bucket "${ARTIFACT_BUCKET}" --versioning-configuration Status=Enabled

      - name: package backend (app + service)
        working-directory: ${{ github.workspace }}
        shell: bash
        run: |
            set -euo pipefail
            test -d backend/app
            test -f backend/scheduler.service
            tar -czf backend_release.tgz \
            --owner=0 --group=0 \
            -C backend app scheduler.service
            ls -lh backend_release.tgz


      - name: upload artifact to s3 (SSE required)
        shell: bash
        run: |
          set -euo pipefail
          OBJECT_KEY="releases/backend_release.tgz"
          aws s3 cp backend_release.tgz "s3://${ARTIFACT_BUCKET}/${OBJECT_KEY}" --sse AES256 --only-show-errors
          echo "OBJECT_KEY=${OBJECT_KEY}" >> "$GITHUB_ENV"

      - name: deploy on instances via ssm (tag-targeted)
        shell: bash
        run: |
          set -euo pipefail

          CMD=$(cat <<'EOS'
          set -euo pipefail
          echo "[deploy] ---------- BEGIN ----------"
          date -u +"[deploy] UTC: %Y-%m-%dT%H:%M:%SZ"
          uname -a || true
          whoami || true
          id || true
          echo "[deploy] ENV: ARTIFACT_BUCKET=${ARTIFACT_BUCKET:-<unset>} OBJECT_KEY=${OBJECT_KEY:-<unset>}"

          : "${ARTIFACT_BUCKET:?missing}"
          : "${OBJECT_KEY:?missing}"
          ARTIFACT_S3="s3://${ARTIFACT_BUCKET}/${OBJECT_KEY}"
          WORKDIR="/opt/app"
          TMP_TGZ="/tmp/backend_release.tgz"
          UNIT_SRC="/tmp/scheduler.service"
          UNIT_DST="/etc/systemd/system/scheduler.service"

          echo "[deploy] ensure workdir: ${WORKDIR}"
          install -d -m 0755 "${WORKDIR}"
          chown ec2-user:ec2-user "${WORKDIR}" || true
          ls -ld "${WORKDIR}" || true

          if ! command -v aws >/dev/null 2>&1; then
            dnf -y install awscli || exit 21
          fi
          aws --version || exit 22
          aws sts get-caller-identity || exit 23

          echo "[deploy] s3 ls object prefix"
          aws s3 ls "s3://${ARTIFACT_BUCKET}/releases/" || exit 24
          echo "[deploy] s3 ls object"
          aws s3 ls "s3://${ARTIFACT_BUCKET}/${OBJECT_KEY}" || exit 25

          echo "[deploy] download: ${ARTIFACT_S3} -> ${TMP_TGZ}"
          aws s3 cp "${ARTIFACT_S3}" "${TMP_TGZ}" || exit 26
          ls -lh "${TMP_TGZ}" || true

          echo "[deploy] list archive contents"
          tar -tzf "${TMP_TGZ}" || exit 27

          echo "[deploy] extract to /tmp"
          rm -rf /tmp/app "${UNIT_SRC}" || true
          tar -xzf "${TMP_TGZ}" -C /tmp
          ls -la /tmp | sed 's/^/[tmp] /'
          ls -la /tmp/app | sed 's/^/[app] /' || true
          ls -la "${UNIT_SRC}" || exit 28

          echo "[deploy] sync app -> ${WORKDIR} (preserve dotfiles like .env)"
          # Delete only non-hidden top-level entries in WORKDIR
          find "${WORKDIR}" -mindepth 1 -maxdepth 1 ! -name '.*' -exec rm -rf {} +
          # Copy only non-hidden entries from the artifact
          find /tmp/app -mindepth 1 -maxdepth 1 ! -name '.*' -exec cp -a {} "${WORKDIR}/" \; || exit 29
          chown -R ec2-user:ec2-user "${WORKDIR}" || true
          ls -la "${WORKDIR}" | sed 's/^/[workdir] /'

          echo "[deploy] install production dependencies"
          if [ -f "${WORKDIR}/package.json" ]; then
            pushd "${WORKDIR}" >/dev/null
            if [ -f package-lock.json ]; then
              npm ci --omit=dev || exit 31
            else
              npm install --omit=dev || exit 31
            fi
            popd >/dev/null
          fi

          echo "[deploy] install systemd unit"
          install -D -m 0644 "${UNIT_SRC}" "${UNIT_DST}"
          head -n 50 "${UNIT_DST}" | sed 's/^/[unit] /' || true

          echo "[deploy] systemd reload + enable --now"
          systemctl daemon-reload
          systemctl enable --now scheduler.service || { systemctl status scheduler.service || true; exit 30; }
          systemctl --no-pager --full status scheduler.service || true
          journalctl -u scheduler.service -n 120 --no-pager || true

          echo "[deploy] ---------- END ----------"
          EOS
          )

          B64=$(printf %s "$CMD" | base64 -w0)

          cat > /tmp/params.json <<JSON
          {
            "commands": [
              "set -euo pipefail",
              "echo ${B64} | base64 -d > /tmp/deploy.sh",
              "chmod +x /tmp/deploy.sh",
              "ARTIFACT_BUCKET=${ARTIFACT_BUCKET} OBJECT_KEY=${OBJECT_KEY} bash /tmp/deploy.sh"
            ],
            "executionTimeout": ["900"],
            "workingDirectory": ["/"]
          }
          JSON

          CID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy backend from artifacts" \
            --targets "Key=${BACKEND_SSM_TARGET_KEY},Values=${BACKEND_SSM_TARGET_VALUE}" \
            --parameters file:///tmp/params.json \
            --max-concurrency "1" \
            --max-errors "0" \
            --region "${AWS_REGION}" \
            --query "Command.CommandId" \
            --output text)

          ATTEMPTS=120
          SLEEP=5
          for i in $(seq 1 ${ATTEMPTS}); do
            STATUS=$(aws ssm list-command-invocations \
              --command-id "${CID}" \
              --details \
              --region "${AWS_REGION}" \
              --query 'CommandInvocations[0].Status' \
              --output text 2>/dev/null || echo "Unknown")
            case "${STATUS}" in
              Success|Cancelled|TimedOut|Failed) break ;;
              *) sleep "${SLEEP}" ;;
            esac
          done

          aws ssm list-command-invocations \
            --command-id "${CID}" \
            --details \
            --region "${AWS_REGION}" \
            --output json > /tmp/ssm_result.json || true
          cat /tmp/ssm_result.json || true

          aws ssm list-command-invocations \
            --command-id "${CID}" \
            --details \
            --region "${AWS_REGION}" \
            --query 'CommandInvocations[0].CommandPlugins[0].Output' \
            --output text || true
          aws ssm list-command-invocations \
            --command-id "${CID}" \
            --details \
            --region "${AWS_REGION}" \
            --query 'CommandInvocations[0].CommandPlugins[0].StandardErrorContent' \
            --output text || true


      - name: show last 80 journal lines (all matching instances)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "Show scheduler.service logs" \
            --targets "Key=${BACKEND_SSM_TARGET_KEY},Values=${BACKEND_SSM_TARGET_VALUE}" \
            --parameters commands="journalctl -u scheduler.service -n 80 --no-pager || true" \
            --max-concurrency "1" \
            --max-errors "0" \
            --region "${AWS_REGION}" \
            --output text --query "Command.CommandId"
