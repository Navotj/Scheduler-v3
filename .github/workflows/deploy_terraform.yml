name: 'Deploy Terraform Infrastructure'

on:
  push:
    branches: [ "main" ]
    paths:
      - 'infrastructure/terraform/**'
      - '.github/workflows/deploy_terraform.yml'
  workflow_dispatch:

permissions:
  contents: read

jobs:
  terraform:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: infrastructure/terraform
    env:
      TF_IN_AUTOMATION: "true"
      TF_VAR_frontend_waf_name: ${{ vars.FRONTEND_WAF_NAME }}
      TF_VAR_attach_frontend_waf: "false"
      TF_VAR_backend_health_check_path: "/"
      TF_REGISTRY_CLIENT_TIMEOUT: "60s"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      #-------------------- Plugin cache --------------------
      - name: Prepare Terraform plugin cache dir
        run: |
          set -euo pipefail
          mkdir -p "${HOME}/.terraform.d/plugin-cache"
          echo "TF_PLUGIN_CACHE_DIR=${HOME}/.terraform.d/plugin-cache" >> "$GITHUB_ENV"

      - name: Cache Terraform plugin cache
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          key: tf-plugin-cache-${{ runner.os }}-${{ hashFiles('infrastructure/terraform/**/*.tf','infrastructure/terraform/.terraform.lock.hcl') }}
          restore-keys: |
            tf-plugin-cache-${{ runner.os }}-

      #-------------------- Backend bootstrap --------------------
      - name: Bootstrap remote state (S3+DDB)
        timeout-minutes: 8
        env:
          AWS_REGION: eu-central-1
        run: |
          set -euo pipefail
          BUCKET="navot-terraform-state-1"
          REGION="${AWS_REGION}"
          DDB_TABLE="terraform-lock-table"

          if ! aws s3api head-bucket --bucket "$BUCKET" >/dev/null 2>&1; then
            aws s3api create-bucket \
              --bucket "$BUCKET" \
              --region "$REGION" \
              --create-bucket-configuration LocationConstraint="$REGION"
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration '{
              "BlockPublicAcls": true,
              "IgnorePublicAcls": true,
              "BlockPublicPolicy": true,
              "RestrictPublicBuckets": true
            }'
          else
            echo "S3 state bucket exists; continuing."
          fi

          if ! aws dynamodb describe-table --table-name "$DDB_TABLE" >/dev/null 2>&1; then
            if ! aws dynamodb create-table \
              --table-name "$DDB_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST >/dev/null 2>&1; then
              if aws dynamodb describe-table --table-name "$DDB_TABLE" >/dev/null 2>&1; then
                echo "DynamoDB lock table already exists; continuing."
              else
                echo "Failed to create or verify DynamoDB lock table '$DDB_TABLE'." >&2
                exit 1
              fi
            fi
            aws dynamodb wait table-exists --table-name "$DDB_TABLE"
          else
            echo "DynamoDB lock table exists; continuing."
          fi

      #-------------------- Terraform init (1 retry, then fail) --------------------
      - name: Terraform Init (1 retry)
        timeout-minutes: 8
        run: |
          set -euo pipefail

          printf '%s\n' \
            'provider_installation {' \
            '  direct {}' \
            '}' > "$HOME/.tfrc.direct"
          cp "$HOME/.tfrc.direct" "$HOME/.terraformrc"
          echo "Using TF CLI config: $HOME/.tfrc.direct"

          attempt=0
          until [ "$attempt" -ge 2 ]; do
            if terraform init -reconfigure -lock-timeout=2m; then
              exit 0
            fi
            attempt=$((attempt+1))
            [ "$attempt" -lt 2 ] && echo "terraform init failed. retrying once in 10s..." && sleep 10
          done
          echo "terraform init failed twice. aborting."
          exit 1

      #-------------------- Optional import of existing artifacts bucket --------------------
      - name: Import deploy artifacts bucket (if exists)
        id: import_artifacts_bucket
        timeout-minutes: 4
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          set -euo pipefail
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ARTIFACT_BUCKET="nat20scheduling-com-deploy-artifacts-${ACCOUNT_ID}"

          if aws s3api head-bucket --bucket "$ARTIFACT_BUCKET" 2>/dev/null; then
            if ! terraform state show aws_s3_bucket.deploy_artifacts >/dev/null 2>&1; then
              echo "Importing existing bucket $ARTIFACT_BUCKET into Terraform state..."
              terraform import aws_s3_bucket.deploy_artifacts "$ARTIFACT_BUCKET"
            else
              echo "Bucket already managed by Terraform state."
            fi
          else
            echo "No existing deploy artifacts bucket found; Terraform will create it."
          fi

      - name: Terraform Validate
        timeout-minutes: 5
        env:
          TF_IN_AUTOMATION: "true"
        run: terraform validate

      - name: Terraform Plan (1 retry)
        timeout-minutes: 10
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          set -euo pipefail
          attempt=0
          until [ "$attempt" -ge 2 ]; do
            if terraform plan -input=false -lock-timeout=2m \
              -var "frontend_waf_name=${{ vars.FRONTEND_WAF_NAME }}" \
              -var "attach_frontend_waf=${{ env.TF_VAR_attach_frontend_waf }}" \
              -var "backend_health_check_path=${{ env.TF_VAR_backend_health_check_path }}"; then
              exit 0
            fi
            attempt=$((attempt+1))
            [ "$attempt" -lt 2 ] && echo "plan failed. retrying once in 10s..." && sleep 10
          done
          echo "plan failed twice. aborting."
          exit 1

      - name: Terraform Apply (1 retry)
        if: github.ref == 'refs/heads/main'
        timeout-minutes: 15
        env:
          TF_IN_AUTOMATION: "true"
        run: |
          set -euo pipefail
          attempt=0
          until [ "$attempt" -ge 2 ]; do
            if terraform apply -auto-approve -input=false -lock-timeout=2m \
              -var "frontend_waf_name=${{ vars.FRONTEND_WAF_NAME }}" \
              -var "attach_frontend_waf=${{ env.TF_VAR_attach_frontend_waf }}" \
              -var "backend_health_check_path=${{ env.TF_VAR_backend_health_check_path }}"; then
              exit 0
            fi
            attempt=$((attempt+1))
            [ "$attempt" -lt 2 ] && echo "apply failed. retrying once in 15s..." && sleep 15
          done
          echo "apply failed twice. aborting."
          exit 1

      #-------------------- CloudFront invalidation to pick up /auth behavior immediately --------------------
      - name: CloudFront Invalidation (/auth/* and index.html)
        timeout-minutes: 4
        run: |
          set -euo pipefail
          DOMAIN="$(terraform output -raw frontend_dns || echo 'nat20scheduling.com')"
          DIST_ID="$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Aliases.Items && (contains(Aliases.Items, '${DOMAIN}') || contains(Aliases.Items, 'www.${DOMAIN}'))].Id | [0]" \
            --output text || true)"
          if [ -n "${DIST_ID}" ] && [ "${DIST_ID}" != "None" ]; then
            aws cloudfront create-invalidation --distribution-id "${DIST_ID}" --paths "/auth/*" "/index.html"
            echo "Created invalidation on ${DIST_ID}."
          else
            echo "Could not resolve CloudFront distribution ID for ${DOMAIN}; skipping invalidation."
          fi

      #-------------------- Quick origin health check (logs only) --------------------
      - name: Check API origin health quickly
        timeout-minutes: 3
        run: |
          set -euo pipefail
          DOMAIN="$(terraform output -raw backend_dns || echo 'api.nat20scheduling.com')"
          code="$(curl -sS -o /dev/null -w "%{http_code}\n" "https://${DOMAIN}/auth/check" || echo "000")"
          echo "HTTPS https://${DOMAIN}/auth/check -> ${code}"
