name: Terraform Apply (EKS hardened, staged)

on:
  push:
    branches: ["main"]
    paths:
      - "**/*.tf"
      - "**/*.tfvars"
      - "infrastructure/**"
      - ".github/workflows/terraform_apply.yml"
  workflow_dispatch:


env:
  AWS_REGION: eu-central-1

jobs:
  tf-apply:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    defaults:
      run:
        shell: bash
        working-directory: infrastructure/terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Terraform Init
        run: terraform init -input=false

      # Avoid contacting the cluster during planning (helm/k8s providers refresh),
      # which can fail when we're rotating public_access_cidrs to the current runner IP.
      - name: Terraform Plan (no refresh)
        run: terraform plan -refresh=false -input=false -lock-timeout=2m -out=tfplan-norefresh

      # Stage 1: update the EKS cluster networking (public_access_cidrs, private endpoint, logging, KMS).
      # This ensures the current runner IP is allowed BEFORE any helm/k8s provider operations run.
      - name: Apply cluster-only changes first
        run: terraform apply -input=false -lock-timeout=2m -auto-approve -target=aws_eks_cluster.this

      # Optional: brief wait for control-plane to accept the CIDR change
      - name: Wait for EKS API reachability
        shell: bash
        env:
          CLUSTER_NAME: nat20-eks
        run: |
          set -euo pipefail
          ENDPOINT="$(aws eks describe-cluster --name "${CLUSTER_NAME}" --query 'cluster.endpoint' --output text)"
          # Strip scheme and any path robustly
          HOST="$(printf '%s\n' "$ENDPOINT" | sed -E 's#^https?://##; s#/.*$##')"
          echo "EKS endpoint host: ${HOST}"

          for i in $(seq 1 60); do
            if timeout 5 bash -lc "echo | openssl s_client -connect ${HOST}:443 -servername ${HOST} >/dev/null 2>&1"; then
              echo "EKS API reachable on ${HOST}:443"
              exit 0
            fi
            echo "Waiting for EKS API to accept new CIDR... (${i}/60)"
            sleep 5
          done

          echo "EKS API not reachable; dumping cluster access config..."
          aws eks describe-cluster --name "${CLUSTER_NAME}" \
            --query 'cluster.resourcesVpcConfig.{publicAccessCidrs:publicAccessCidrs,endpointPublicAccess:endpointPublicAccess,endpointPrivateAccess:endpointPrivateAccess}' \
            --output json || true
          exit 1


      # Stage 2: apply the rest (Helm releases for ALB Controller, External Secrets, etc.)
      - name: Terraform Apply (everything)
        run: terraform apply -input=false -lock-timeout=2m -auto-approve

      - name: Output
        run: terraform output -json || true
