name: Deploy Mongo to EKS

on:
  push:
    branches: ["main"]
    paths:
      - ".github/workflows/deploy_mongo.yml"
      - "infrastructure/k8s/mongo/**"
      - "infrastructure/k8s/externalsecrets/mongo-secrets.yaml"
      - "infrastructure/k8s/secret-stores/clustersecretstore.yaml"
      - "infrastructure/k8s/storageclasses/gp3.yaml"
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: eu-central-1
      CLUSTER_NAME: nat20-eks
      # Optional: set a safer CIDR allowlist for this job; default widens fully, then we restore.
      EKS_JOB_PUBLIC_CIDRS: 0.0.0.0/0

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (SDK v3)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Capture current EKS endpoint and CIDR allowlist
        id: capture
        shell: bash
        run: |
          set -euo pipefail
          EP="$(aws eks describe-cluster --name "${CLUSTER_NAME}" --region "${AWS_REGION}" --query 'cluster.endpoint' --output text)"
          CIDRS="$(aws eks describe-cluster --name "${CLUSTER_NAME}" --region "${AWS_REGION}" --query 'cluster.resourcesVpcConfig.publicAccessCidrs' --output text | sed 's/\t/,/g')"
          echo "EKS_ENDPOINT=${EP}" >> "$GITHUB_ENV"
          echo "ORIGINAL_EKS_API_CIDRS=${CIDRS}" >> "$GITHUB_ENV"
          echo "endpoint=${EP}" >> "$GITHUB_OUTPUT"
          echo "cidrs=${CIDRS}" >> "$GITHUB_OUTPUT"

      - name: Temporarily widen EKS API CIDRs and wait for update
        shell: bash
        run: |
          set -euo pipefail
          TARGET="${EKS_JOB_PUBLIC_CIDRS:-0.0.0.0/0}"

          CURRENT="$(aws eks describe-cluster --name "${CLUSTER_NAME}" --region "${AWS_REGION}" \
            --query 'cluster.resourcesVpcConfig.publicAccessCidrs' --output text | sed 's/\t/,/g')"

          if [ "${CURRENT}" != "${TARGET}" ]; then
            RESP="$(aws eks update-cluster-config --name "${CLUSTER_NAME}" --region "${AWS_REGION}" \
              --resources-vpc-config publicAccessCidrs="${TARGET}" --output json)"
            UPD_ID="$(jq -r '.update.id' <<<"${RESP}")"
            [ -z "${UPD_ID}" ] && { echo "Failed to get update id"; echo "${RESP}"; exit 1; }

            # Poll update until Successful/Failed (max ~2min)
            for i in $(seq 1 24); do
              STATUS="$(aws eks describe-update --name "${CLUSTER_NAME}" --region "${AWS_REGION}" \
                --update-id "${UPD_ID}" --query 'update.status' --output text || echo "Unknown")"
              if [ "${STATUS}" = "Successful" ]; then
                echo "EKS CIDR update Successful"; break
              elif [ "${STATUS}" = "Failed" ]; then
                echo "EKS CIDR update Failed"; aws eks describe-update --name "${CLUSTER_NAME}" --region "${AWS_REGION}" \
                  --update-id "${UPD_ID}"; exit 1
              fi
              sleep 5
              [ $i -eq 24 ] && { echo "Timed out waiting for EKS CIDR update"; exit 1; }
            done
          fi

          # Quick connectivity probe to API endpoint (fail fast with retries)
          HOST="$(echo "${EKS_ENDPOINT}" | sed -E 's#https?://##g')"
          for i in 1 2 3 4 5 6 7 8 9 10; do
            if timeout 3 bash -lc "exec 3<>/dev/tcp/${HOST}/443"; then
              exec 3>&-
              echo "EKS endpoint reachable."
              exit 0
            fi
            sleep 2
          done
          echo "EKS endpoint NOT reachable after retries."
          exit 1

      - name: Configure kubectl
        shell: bash
        run: |
          set -euo pipefail
          aws eks update-kubeconfig --name "${CLUSTER_NAME}" --region "${AWS_REGION}"

      - name: Ensure namespaces exist + label PSS (restricted)
        shell: bash
        run: |
          set -euo pipefail
          kubectl get ns nat20 >/dev/null 2>&1 || kubectl create ns nat20
          kubectl get ns externalsecrets >/dev/null 2>&1 || kubectl create ns externalsecrets
          kubectl label ns nat20 \
            pod-security.kubernetes.io/enforce=restricted \
            pod-security.kubernetes.io/audit=restricted \
            pod-security.kubernetes.io/warn=restricted \
            --overwrite || true

      - name: Ensure External Secrets CRDs (server-side, pinned)
        shell: bash
        run: |
          set -euo pipefail
          kubectl apply --server-side -f https://raw.githubusercontent.com/external-secrets/external-secrets/v0.19.2/deploy/crds/bundle.yaml
          kubectl wait --for=condition=Established crd clustersecretstores.external-secrets.io --timeout=120s
          kubectl wait --for=condition=Established crd secretstores.external-secrets.io --timeout=120s
          kubectl wait --for=condition=Established crd externalsecrets.external-secrets.io --timeout=120s

      - name: Ensure AWS EBS CSI driver add-on is ACTIVE
        shell: bash
        run: |
          set -euo pipefail
          STATUS="$(aws eks describe-addon --cluster-name "${CLUSTER_NAME}" --addon-name aws-ebs-csi-driver \
            --query 'addon.status' --output text 2>/dev/null || echo "NONE")"
          if [ "${STATUS}" != "ACTIVE" ]; then
            # Try create, else update if it already exists
            if ! aws eks create-addon --cluster-name "${CLUSTER_NAME}" --addon-name aws-ebs-csi-driver \
              --resolve-conflicts OVERWRITE >/dev/null 2>&1; then
              aws eks update-addon --cluster-name "${CLUSTER_NAME}" --addon-name aws-ebs-csi-driver \
                --resolve-conflicts OVERWRITE >/dev/null
            fi
            # Poll until ACTIVE (max ~3min)
            for i in $(seq 1 36); do
              STATUS="$(aws eks describe-addon --cluster-name "${CLUSTER_NAME}" --addon-name aws-ebs-csi-driver \
                --query 'addon.status' --output text 2>/dev/null || echo "NONE")"
              [ "${STATUS}" = "ACTIVE" ] && { echo "aws-ebs-csi-driver ACTIVE"; break; }
              sleep 5
              [ $i -eq 36 ] && { echo "Timed out waiting for aws-ebs-csi-driver to be ACTIVE (last: ${STATUS})"; exit 1; }
            done
          else
            echo "aws-ebs-csi-driver already ACTIVE"
          fi

      - name: Apply gp3 StorageClass
        shell: bash
        run: |
          set -euo pipefail
          kubectl apply -f infrastructure/k8s/storageclasses/gp3.yaml
          kubectl get sc gp3

      - name: Preflight check required SSM params
        shell: bash
        run: |
          set -euo pipefail
          MISSING=0
          for KEY in /nat20/mongo/USER /nat20/mongo/PASSWORD; do
            if ! aws ssm get-parameter --name "$KEY" >/dev/null 2>&1; then
              echo "Missing SSM parameter: $KEY" >&2
              MISSING=1
            fi
          done
          [ $MISSING -ne 0 ] && { echo "Required SSM parameters missing; aborting." >&2; exit 1; }

      - name: Apply ClusterSecretStore and Mongo ExternalSecret
        shell: bash
        run: |
          set -euo pipefail
          kubectl apply -f infrastructure/k8s/secret-stores/clustersecretstore.yaml
          kubectl apply -n nat20 -f infrastructure/k8s/externalsecrets/mongo-secrets.yaml
          # Wait for secret materialization (retry-based, 60s)
          for i in $(seq 1 12); do
            kubectl -n nat20 get secret mongo-root >/dev/null 2>&1 && break
            sleep 5
            [ $i -eq 12 ] && { echo "mongo-root Secret not created in time"; exit 1; }
          done

      - name: Deploy MongoDB (Services + StatefulSet) and wait for PVC bind
        shell: bash
        run: |
          set -euo pipefail
          MANIFEST="infrastructure/k8s/mongo/statefulset.yaml"

          # Apply Services and StatefulSet
          kubectl apply -n nat20 -f "${MANIFEST}"

          # Wait for PVC to bind (max ~5min)
          for i in $(seq 1 30); do
            PHASE="$(kubectl -n nat20 get pvc mongo-data-mongo-0 -o jsonpath='{.status.phase}' 2>/dev/null || true)"
            if [ "${PHASE}" = "Bound" ]; then
              echo "PVC bound."
              break
            fi
            sleep 10
            [ $i -eq 30 ] && { echo "PVC did not bind in time"; kubectl -n nat20 describe pvc mongo-data-mongo-0 || true; exit 1; }
          done

          # Rollout wait (max 5min)
          kubectl -n nat20 rollout status statefulset/mongo --timeout=300s

      - name: Output Mongo service
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n nat20 get svc mongo -o wide || true

      - name: Restore original EKS API CIDR allowlist
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${ORIGINAL_EKS_API_CIDRS:-}" ]; then
            CURRENT="$(aws eks describe-cluster --name "${CLUSTER_NAME}" --region "${AWS_REGION}" \
              --query 'cluster.resourcesVpcConfig.publicAccessCidrs' --output text | sed 's/\t/,/g')"
            if [ "${CURRENT}" != "${ORIGINAL_EKS_API_CIDRS}" ]; then
              set +e
              aws eks update-cluster-config --name "${CLUSTER_NAME}" --region "${AWS_REGION}" \
                --resources-vpc-config publicAccessCidrs="${ORIGINAL_EKS_API_CIDRS}" >/dev/null 2>&1
              set -e
            fi
          fi
