name: Diagnose Terraform

on:
  workflow_dispatch: {}

defaults:
  run:
    working-directory: infrastructure/terraform

concurrency:
  group: diag-${{ github.ref }}
  cancel-in-progress: true

jobs:
  diagnose:
    runs-on: ubuntu-latest
    env:
      APP_PREFIX: ${{ vars.APP_PREFIX }}
      AWS_REGION: ${{ vars.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_PAGER: ""

      TF_VAR_app_prefix: ${{ vars.APP_PREFIX }}
      TF_VAR_root_domain: ${{ vars.ROOT_DOMAIN }}
      TF_VAR_ec2_instance_type: ${{ vars.EC2_INSTANCE_TYPE }}

      # Optional DB secrets check
      DATABASE_USER: ${{ secrets.database_user }}
      DATABASE_PASSWORD: ${{ secrets.database_password }}
      TF_VAR_database_user: ${{ secrets.database_user }}
      TF_VAR_database_password: ${{ secrets.database_password }}

      TF_IN_AUTOMATION: true

    steps:
      - name: Checkout repo
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.0

      - name: Ensure jq and awscli deps are available
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Verify required files exist
        run: |
          set -euo pipefail
          test -f main.tf || true
          test -f variables.tf || true
          test -f vpc.tf
          test -f vpc_endpoints.tf
          test -f security_groups.tf
          test -f ec2.tf
          test -f scripts/user_data_envwrap.tpl
          test -f scripts/user_data_database.sh

      - name: Terraform Init (S3 backend with native lockfile)
        run: |
          set -euo pipefail
          terraform init \
            -backend-config="bucket=${APP_PREFIX}-state-bucket" \
            -backend-config="key=state/${APP_PREFIX}.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="use_lockfile=true" \
            -backend-config="encrypt=true"

      - name: Terraform Format and Validate
        run: |
          set -euo pipefail
          terraform fmt -check
          terraform validate -no-color

      - name: Capture state resources (if any)
        run: |
          set -euo pipefail
          echo "Listing resources in state (if state exists):"
          terraform state list || true

      - name: Resolve key IDs and outputs
        id: ids
        shell: bash
        run: |
          set -euo pipefail

          # Best effort reads; many may not exist yet, so do not fail
          get_id () { terraform state show "$1" 2>/dev/null | awk '/^id +=/ {print $3; exit}'; }

          VPC_ID="$(get_id aws_vpc.main)"
          SUBNET_PRIVATE_ID="$(get_id aws_subnet.private_a)"
          SG_BACKEND_INGRESS_ID="$(get_id aws_security_group.backend_ingress)"
          SG_BACKEND_EGRESS_ID="$(get_id aws_security_group.backend_egress)"
          SG_DATABASE_INGRESS_ID="$(get_id aws_security_group.database_ingress)"
          SG_DATABASE_EGRESS_ID="$(get_id aws_security_group.database_egress)"
          SG_EIC_ID="$(get_id aws_security_group.backend_ssh)"
          RT_PRIVATE_ID="$(get_id aws_route_table.private)"
          EIC_ID="$(get_id aws_ec2_instance_connect_endpoint.eic)"

          BACKEND_INSTANCE_ID="$(get_id aws_instance.backend)"
          DATABASE_INSTANCE_ID="$(get_id aws_instance.database)"

          echo "VPC_ID=$VPC_ID" >> $GITHUB_OUTPUT
          echo "SUBNET_PRIVATE_ID=$SUBNET_PRIVATE_ID" >> $GITHUB_OUTPUT
          echo "SG_BACKEND_INGRESS_ID=$SG_BACKEND_INGRESS_ID" >> $GITHUB_OUTPUT
          echo "SG_BACKEND_EGRESS_ID=$SG_BACKEND_EGRESS_ID" >> $GITHUB_OUTPUT
          echo "SG_DATABASE_INGRESS_ID=$SG_DATABASE_INGRESS_ID" >> $GITHUB_OUTPUT
          echo "SG_DATABASE_EGRESS_ID=$SG_DATABASE_EGRESS_ID" >> $GITHUB_OUTPUT
          echo "SG_EIC_ID=$SG_EIC_ID" >> $GITHUB_OUTPUT
          echo "RT_PRIVATE_ID=$RT_PRIVATE_ID" >> $GITHUB_OUTPUT
          echo "EIC_ID=$EIC_ID" >> $GITHUB_OUTPUT
          echo "BACKEND_INSTANCE_ID=$BACKEND_INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "DATABASE_INSTANCE_ID=$DATABASE_INSTANCE_ID" >> $GITHUB_OUTPUT

      - name: CloudFront alias sanity check
        shell: bash
        run: |
          set -euo pipefail
          ROOT_DOMAIN="${{ vars.ROOT_DOMAIN }}"
          FRONTEND_HOSTNAME="$(terraform output -raw frontend_hostname 2>/dev/null || true)"
          if [[ -z "${FRONTEND_HOSTNAME}" || "${FRONTEND_HOSTNAME}" == "None" ]]; then
            FRONTEND_HOSTNAME="www.${ROOT_DOMAIN}"
          fi
          echo "Expected frontend alias: ${FRONTEND_HOSTNAME}"

          CF_ID_STATE=""
          if terraform state list | grep -q '^aws_cloudfront_distribution.frontend$'; then
            CF_ID_STATE="$(terraform state show aws_cloudfront_distribution.frontend | awk '/^id +=/ {print $3; exit}')"
          fi
          echo "CloudFront in state: ${CF_ID_STATE:-<none>}"

          CF_ID_ALIAS="$(aws cloudfront list-distributions --query "DistributionList.Items[?Aliases && Aliases.Items && contains(Aliases.Items, \`${FRONTEND_HOSTNAME}\`)].Id" --output text 2>/dev/null || true)"
          [[ "${CF_ID_ALIAS}" == "None" ]] && CF_ID_ALIAS=""
          echo "CloudFront in AWS by alias: ${CF_ID_ALIAS:-<none>}"

      - name: VPC endpoints status
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          REGION="${AWS_REGION}"
          VPC_ID="${{ steps.ids.outputs.VPC_ID }}"
          SUBNET_PRIVATE_ID="${{ steps.ids.outputs.SUBNET_PRIVATE_ID }}"

          if [[ -z "$VPC_ID" ]]; then
            echo "No VPC in state; skipping VPC endpoint checks."
            exit 0
          fi

          echo "Checking interface endpoints in VPC $VPC_ID:"
          aws ec2 describe-vpc-endpoints \
            --filters Name=vpc-id,Values="$VPC_ID" \
            --query "VpcEndpoints[].{Id:VpcEndpointId,Service:ServiceName,Type:VpcEndpointType,State:State,Subnets:SubnetIds}" \
            --output table || true

          echo "Expect SSM endpoints (Interface): ssm, ec2messages, ssmmessages"
          # Quick existence checks by service name
          for svc in ssm ec2messages ssmmessages; do
            COUNT="$(aws ec2 describe-vpc-endpoints \
              --filters Name=vpc-id,Values="$VPC_ID" Name=service-name,Values="com.amazonaws.${REGION}.${svc}" \
              --query 'length(VpcEndpoints)' --output text || echo 0)"
            echo "Service ${svc}: count=${COUNT}"
          done

          echo "Checking S3 Gateway endpoint on private route table:"
          RT_PRIVATE_ID="${{ steps.ids.outputs.RT_PRIVATE_ID }}"
          if [[ -n "$RT_PRIVATE_ID" ]]; then
            aws ec2 describe-vpc-endpoints \
              --filters Name=vpc-id,Values="$VPC_ID" Name=vpc-endpoint-type,Values=Gateway Name=service-name,Values="com.amazonaws.${REGION}.s3" \
              --query "VpcEndpoints[?contains(RouteTableIds, \`${RT_PRIVATE_ID}\`)].{Id:VpcEndpointId,State:State}" \
              --output table || true
          else
            echo "Private route table not found in state."
          fi

      - name: Route table sanity check
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          RT_PRIVATE_ID="${{ steps.ids.outputs.RT_PRIVATE_ID }}"
          if [[ -z "$RT_PRIVATE_ID" ]]; then
            echo "No private route table in state; skipping."
            exit 0
          fi
          echo "Routes on private RT $RT_PRIVATE_ID:"
          aws ec2 describe-route-tables --route-table-ids "$RT_PRIVATE_ID" \
            --query "RouteTables[].Routes[].{Dest:DestinationCidrBlock,Target:NatGatewayId,State:State,PlId:GatewayId,PrefixListId:DestinationPrefixListId}" \
            --output table

      - name: Security group rule counts and key rules
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          check_sg () {
            local sgid="$1"
            local name="$2"
            if [[ -z "$sgid" ]]; then
              echo "$name not found in state"
              return
            fi
            echo "----- $name ($sgid) -----"
            aws ec2 describe-security-groups --group-ids "$sgid" --query "SecurityGroups[0].{Ingress:IpPermissions, Egress:IpPermissionsEgress}" >/tmp/sg.json
            IN_CNT=$(jq '(.Ingress // []) | length' /tmp/sg.json)
            EG_CNT=$(jq '(.Egress // []) | length' /tmp/sg.json)
            echo "Ingress rules: $IN_CNT"
            echo "Egress rules:  $EG_CNT"
            if (( IN_CNT + EG_CNT > 60 )); then
              echo "ERROR: Rules per SG exceed 60"
              exit 2
            fi
          }

          check_sg "${{ steps.ids.outputs.SG_BACKEND_INGRESS_ID }}" "backend_ingress"
          check_sg "${{ steps.ids.outputs.SG_BACKEND_EGRESS_ID }}"  "backend_egress"
          check_sg "${{ steps.ids.outputs.SG_DATABASE_INGRESS_ID }}" "database_ingress"
          check_sg "${{ steps.ids.outputs.SG_DATABASE_EGRESS_ID }}"  "database_egress"
          check_sg "${{ steps.ids.outputs.SG_EIC_ID }}" "backend_ssh (EIC SG)"

          echo "Verify SSH 22 allowed from EIC SG to backend and database:"
          EIC_SG="${{ steps.ids.outputs.SG_EIC_ID }}"
          BE_ING="${{ steps.ids.outputs.SG_BACKEND_INGRESS_ID }}"
          DB_ING="${{ steps.ids.outputs.SG_DATABASE_INGRESS_ID }}"
          if [[ -n "$EIC_SG" && -n "$BE_ING" ]]; then
            aws ec2 describe-security-groups --group-ids "$BE_ING" \
              --query "SecurityGroups[0].IpPermissions[?FromPort==\`22\` && ToPort==\`22\` && IpProtocol=='tcp' && contains(UserIdGroupPairs[].GroupId, \`${EIC_SG}\`)]" \
              --output json | jq -e 'length>0' >/dev/null || { echo "ERROR: backend_ingress missing SSH from EIC SG"; exit 2; }
          fi
          if [[ -n "$EIC_SG" && -n "$DB_ING" ]]; then
            aws ec2 describe-security-groups --group-ids "$DB_ING" \
              --query "SecurityGroups[0].IpPermissions[?FromPort==\`22\` && ToPort==\`22\` && IpProtocol=='tcp' && contains(UserIdGroupPairs[].GroupId, \`${EIC_SG}\`)]" \
              --output json | jq -e 'length>0' >/dev/null || { echo "ERROR: database_ingress missing SSH from EIC SG"; exit 2; }
          fi

          echo "Verify backend_egress allows TCP 27017 to VPC CIDR:"
          BE_EG="${{ steps.ids.outputs.SG_BACKEND_EGRESS_ID }}"
          VPC_ID="${{ steps.ids.outputs.VPC_ID }}"
          if [[ -n "$BE_EG" && -n "$VPC_ID" ]]; then
            VPC_CIDR=$(aws ec2 describe-vpcs --vpc-ids "$VPC_ID" --query "Vpcs[0].CidrBlock" --output text)
            aws ec2 describe-security-groups --group-ids "$BE_EG" \
              --query "SecurityGroups[0].IpPermissionsEgress[?FromPort==\`27017\` && ToPort==\`27017\` && IpProtocol=='tcp' && contains(IpRanges[].CidrIp, \`${VPC_CIDR}\`)]" \
              --output json | jq -e 'length>0' >/dev/null || { echo "ERROR: backend_egress missing 27017 to VPC CIDR"; exit 2; }
          fi

      - name: EIC endpoint state and AZ alignment
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          SUBNET_PRIVATE_ID="${{ steps.ids.outputs.SUBNET_PRIVATE_ID }}"
          EIC_ID="${{ steps.ids.outputs.EIC_ID }}"
          BACKEND_INSTANCE_ID="${{ steps.ids.outputs.BACKEND_INSTANCE_ID }}"
          DATABASE_INSTANCE_ID="${{ steps.ids.outputs.DATABASE_INSTANCE_ID }}"

          if [[ -z "$SUBNET_PRIVATE_ID" ]]; then
            echo "No private subnet in state; skipping EIC checks."
            exit 0
          fi

          echo "EIC endpoints in the private subnet:"
          aws ec2 describe-instance-connect-endpoints \
            --filters Name=subnet-id,Values="$SUBNET_PRIVATE_ID" \
            --query "InstanceConnectEndpoints[].{Id:InstanceConnectEndpointId,State:State,SubnetId:SubnetId}" \
            --output table || true

          if [[ -n "$EIC_ID" ]]; then
            echo "Detail for EIC $EIC_ID:"
            aws ec2 describe-instance-connect-endpoints --instance-connect-endpoint-ids "$EIC_ID" \
              --query "InstanceConnectEndpoints[].{Id:InstanceConnectEndpointId,State:State,SubnetId:SubnetId,SecurityGroups:SecurityGroupIds}" \
              --output table || true
          fi

          az_of () { aws ec2 describe-instances --instance-ids "$1" --query "Reservations[0].Instances[0].Placement.AvailabilityZone" --output text 2>/dev/null || true; }
          az_subnet () { aws ec2 describe-subnets --subnet-ids "$1" --query "Subnets[0].AvailabilityZone" --output text 2>/dev/null || true; }

          SUBNET_AZ="$(az_subnet "$SUBNET_PRIVATE_ID")"
          echo "Private subnet AZ: ${SUBNET_AZ:-unknown}"

          if [[ -n "$BACKEND_INSTANCE_ID" ]]; then
            B_AZ="$(az_of "$BACKEND_INSTANCE_ID")"
            echo "Backend instance AZ: ${B_AZ:-unknown}"
            if [[ -n "$SUBNET_AZ" && -n "$B_AZ" && "$SUBNET_AZ" != "$B_AZ" ]]; then
              echo "ERROR: Backend instance is not in the same AZ as EIC subnet"
              exit 2
            fi
          fi

          if [[ -n "$DATABASE_INSTANCE_ID" ]]; then
            D_AZ="$(az_of "$DATABASE_INSTANCE_ID")"
            echo "Database instance AZ: ${D_AZ:-unknown}"
            if [[ -n "$SUBNET_AZ" && -n "$D_AZ" && "$SUBNET_AZ" != "$D_AZ" ]]; then
              echo "ERROR: Database instance is not in the same AZ as EIC subnet"
              exit 2
            fi
          fi

      - name: Instances network interfaces and SG attachment verification
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          BACKEND_INSTANCE_ID="${{ steps.ids.outputs.BACKEND_INSTANCE_ID }}"
          DATABASE_INSTANCE_ID="${{ steps.ids.outputs.DATABASE_INSTANCE_ID }}"

          show_sgs () {
            local iid="$1"
            aws ec2 describe-instances --instance-ids "$iid" \
              --query "Reservations[0].Instances[0].SecurityGroups[].GroupId" \
              --output text 2>/dev/null || true
          }

          if [[ -n "$BACKEND_INSTANCE_ID" ]]; then
            echo "Backend instance SGs:"
            show_sgs "$BACKEND_INSTANCE_ID"
          else
            echo "No backend instance found in state."
          fi

          if [[ -n "$DATABASE_INSTANCE_ID" ]]; then
            echo "Database instance SGs:"
            show_sgs "$DATABASE_INSTANCE_ID"
          else
            echo "No database instance found in state."
          fi

      - name: Optional SSM registration check
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          # This will list all SSM managed instances if any; non-fatal if none yet
          aws ssm describe-instance-information \
            --query "InstanceInformationList[].{Id:InstanceId,Platform:PlatformName,Agent:AgentVersion,Ping:PingStatus}" \
            --output table || true

      - name: Final result
        if: always()
        run: |
          echo "Diagnostics completed. Any ERROR lines above indicate required fixes."
